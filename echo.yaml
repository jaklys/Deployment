stages:
  - cascade-merge

cascade_merge_test:
  stage: cascade-merge
  image: alpine:latest
  rules:
    - if: '$CI_COMMIT_REF_NAME =~ /^release\/[A-Za-z]+\.[A-Za-z]+\.\d{4}\.\d{2}\.\d{2}$/ && $CI_MERGE_REQUEST_LABELS !~ /auto-cascade/'
    - if: '$CI_COMMIT_REF_NAME =~ /^release\/[A-Za-z]+\.[A-Za-z]+\.\d{4}\.\d{2}\.\d{2}$/ && $CI_PIPELINE_SOURCE == "push"'
  variables:
    GIT_STRATEGY: none
    MAX_MERGE_TARGETS: 50
    CREATE_MR_ON_CONFLICT: "true"
    GITLAB_URL: "gitlab.com"
    PROJECT_PATH: "your-group/your-project"
  before_script:
    - apk add --no-cache git bash jq curl
    - echo "========================================="
    - echo "CASCADE MERGE TEST MODE (DRY RUN)"
    - echo "========================================="
    - git config --global user.name "CI Bot"
    - git config --global user.email "ci-bot@example.com"
    - |
      echo "Configuration:"
      echo "  GitLab URL: $GITLAB_URL"
      echo "  Project: $PROJECT_PATH"
      echo ""
      echo "Testing repository access..."
      if [ -n "$PROJECT_ACCESS_TOKEN" ]; then
        echo "✓ PROJECT_ACCESS_TOKEN is set"
      else
        echo "⚠️  No PROJECT_ACCESS_TOKEN found - will try CI_JOB_TOKEN (read-only)"
      fi
  script:
    - |
      echo "Testing clone operation..."
      if [ -n "$PROJECT_ACCESS_TOKEN" ]; then
        CLONE_URL="https://oauth2:${PROJECT_ACCESS_TOKEN}@${GITLAB_URL}/${PROJECT_PATH}.git"
        echo "Clone URL: https://oauth2:[MASKED]@${GITLAB_URL}/${PROJECT_PATH}.git"
      else
        CLONE_URL="https://gitlab-ci-token:${CI_JOB_TOKEN}@${GITLAB_URL}/${PROJECT_PATH}.git"
        echo "Clone URL: https://gitlab-ci-token:[MASKED]@${GITLAB_URL}/${PROJECT_PATH}.git"
        echo "⚠️  WARNING: CI_JOB_TOKEN cannot push changes! Add PROJECT_ACCESS_TOKEN for full functionality."
      fi
      
      echo "Executing: git clone --depth=1 [MASKED_URL] project"
      git clone --depth=1 "$CLONE_URL" project || {
        echo "✗ Clone failed - check your token and project path"
        exit 1
      }
    - cd project
    - echo "✓ Repository cloned successfully"
    - git fetch --all --prune
    - CURRENT_BRANCH="${CI_COMMIT_REF_NAME}"
    - VERSION="${CURRENT_BRANCH##release/}"
    - TYPE_AND_YEAR="${VERSION%.*.*}"
    - SUFFIX="${VERSION##$TYPE_AND_YEAR.}"
    - PREFIX="release/$TYPE_AND_YEAR"
    - echo ""
    - echo "Branch Analysis:"
    - echo "================"
    - echo "Current branch: $CURRENT_BRANCH"
    - echo "Version: $VERSION"
    - echo "Type and Year: $TYPE_AND_YEAR"
    - echo "Suffix: $SUFFIX"
    - echo "Prefix to match: $PREFIX"
    - |
      echo ""
      echo "Fetching remote branches..."
      ALL_BRANCHES=$(git ls-remote --heads origin | grep -E 'refs/heads/release/' | sed 's|.*refs/heads/||')
      echo "Found $(echo "$ALL_BRANCHES" | wc -l) release branches total"
    - |
      MATCHING_BRANCHES=$(echo "$ALL_BRANCHES" | grep "^$PREFIX\\." || true)
      if [ -n "$MATCHING_BRANCHES" ]; then
        echo ""
        echo "Branches with same prefix ($PREFIX):"
        echo "$MATCHING_BRANCHES" | sed 's/^/  - /'
      else
        echo "No branches found with prefix $PREFIX"
      fi
    - TARGET_BRANCHES=""
    - BRANCH_COUNT=0
    - |
      echo ""
      echo "Analyzing version numbers..."
      for BRANCH in $MATCHING_BRANCHES; do
        OTHER_SUFFIX="${BRANCH##$PREFIX.}"
        echo -n "  - $BRANCH: suffix=$OTHER_SUFFIX "
        if [[ "$OTHER_SUFFIX" > "$SUFFIX" ]]; then
          echo "✓ (newer - will merge)"
          TARGET_BRANCHES="$TARGET_BRANCHES $BRANCH"
          ((BRANCH_COUNT++))
        else
          echo "✗ (older or same - skip)"
        fi
      done
    - |
      echo ""
      echo "Checking for master/main branches..."
      if git ls-remote --heads origin | grep -q 'refs/heads/master'; then
        echo "✓ Found master branch"
        TARGET_BRANCHES="$TARGET_BRANCHES master"
        ((BRANCH_COUNT++))
      fi
      if git ls-remote --heads origin | grep -q 'refs/heads/main'; then
        echo "✓ Found main branch"
        TARGET_BRANCHES="$TARGET_BRANCHES main"
        ((BRANCH_COUNT++))
      fi
    - |
      echo ""
      echo "========================================="
      echo "CASCADE MERGE PLAN"
      echo "========================================="
      echo "From: $CURRENT_BRANCH"
      echo "Total targets: $BRANCH_COUNT"
      if [ -n "$TARGET_BRANCHES" ]; then
        echo "Will merge to:"
        for TARGET in $TARGET_BRANCHES; do
          echo "  → $TARGET"
        done
      else
        echo "No target branches found!"
      fi
    - |
      echo ""
      echo "Testing GitLab API access..."
      if [ -n "$PROJECT_ACCESS_TOKEN" ]; then
        API_TEST=$(curl -s -o /dev/null -w "%{http_code}" \
          --header "PRIVATE-TOKEN: ${PROJECT_ACCESS_TOKEN}" \
          "https://${GITLAB_URL}/api/v4/projects/${CI_PROJECT_ID}")
        if [ "$API_TEST" = "200" ]; then
          echo "✓ API access successful"
        else
          echo "✗ API access failed (HTTP $API_TEST)"
        fi
      fi
    - |
      if [ $BRANCH_COUNT -gt 0 ]; then
        echo ""
        echo "========================================="
        echo "SIMULATING MERGE OPERATIONS"
        echo "========================================="
        MERGE_ATTEMPTS=0
        
        for TARGET in $TARGET_BRANCHES; do
          ((MERGE_ATTEMPTS++))
          echo ""
          echo "[$MERGE_ATTEMPTS/$BRANCH_COUNT] Target: $TARGET"
          echo "----------------------------------------"
          
          echo "Would execute: git checkout -B $TARGET origin/$TARGET"
          git checkout -B $TARGET origin/$TARGET 2>/dev/null && echo "✓ Checkout successful" || echo "✗ Checkout would fail"
          
          echo "Would execute: git merge origin/$CI_COMMIT_REF_NAME --no-ff --no-commit"
          if git merge origin/$CI_COMMIT_REF_NAME --no-ff --no-commit >/dev/null 2>&1; then
            if git diff --cached --quiet; then
              echo "ℹ️  Result: No changes (already merged)"
            else
              echo "✓ Result: Clean merge possible"
              echo "Would execute: git push origin $TARGET"
            fi
            git merge --abort 2>/dev/null
          else
            echo "⚠️  Result: Merge conflict detected!"
            git merge --abort 2>/dev/null
            
            if [[ "$CREATE_MR_ON_CONFLICT" == "true" ]]; then
              MERGE_BRANCH="auto-merge/${CI_COMMIT_REF_NAME//\//-}-to-${TARGET//\//-}-$(date +%s)"
              echo "Would create branch: $MERGE_BRANCH"
              echo "Would create MR with labels: [auto-cascade, merge-conflict]"
              echo ""
              echo "Would call API:"
              echo "  POST https://${GITLAB_URL}/api/v4/projects/$CI_PROJECT_ID/merge_requests"
              echo "  With auto-cascade label to prevent loops"
            fi
          fi
          
          git reset --hard HEAD >/dev/null 2>&1
        done
      fi
    - |
      echo ""
      echo "========================================="
      echo "DRY RUN COMPLETE"
      echo "========================================="
      echo "This was a TEST RUN - no actual changes were made"
      echo ""
      echo "Environment check:"
      echo "  ✓ GitLab URL: $GITLAB_URL"
      echo "  ✓ Project Path: $PROJECT_PATH"
      echo "  ✓ CI_PROJECT_ID: $CI_PROJECT_ID"
      echo "  ✓ CI_COMMIT_REF_NAME: $CI_COMMIT_REF_NAME"
      echo "  ✓ CI_PIPELINE_SOURCE: $CI_PIPELINE_SOURCE"
      echo "  ✓ CI_MERGE_REQUEST_LABELS: ${CI_MERGE_REQUEST_LABELS:-none}"
      if [ -n "$PROJECT_ACCESS_TOKEN" ]; then
        echo "  ✓ PROJECT_ACCESS_TOKEN: set"
      else
        echo "  ⚠️  PROJECT_ACCESS_TOKEN: not set"
      fi
      echo ""
      echo "Next steps:"
      echo "1. Verify the output above looks correct"
      echo "2. Change 'cascade_merge_test' to 'cascade_merge'"
      echo "3. Remove echo/Would prefixes for actual execution"